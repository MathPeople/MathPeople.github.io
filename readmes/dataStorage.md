# Data Storage

The primary purpose of this editor is to create a folder of files, one file for each problem, which you download to your computer and then upload to GitHub where they become part of the site. There are a few levels of storage between a blank page and a finished problems folder, so we describe them here.

# During a Browser Session

When you are on the TeX editor page you have a copy of the active problems repository loaded at all times, stored by id. At first this is empty, but you can import a qual (see below) and once you do that you will have that qual's problems loaded. Most of these problems are inactive, just sitting in the  background (the javascript engine powering your browser), but there is always one active problem. The active problem is the one which is displayed in the GUI. Clicking the Clear/New Problem button blurs the currently active problem (not erasing it, it just loses the focus) and focuses on a problem with id `changeMe`, then it resets all the data in the GUI/active problem to be blank. Unless the previously active problem also had the id `changeMe` it will not be lost in this process but will instead be stored and accessible by whatever id it has.

When it is asked to save problems, this editor ignores a problem if its id is `changeMe`, which is also what it starts a blank problem as. If you don't want to lose the problem you have to change the id by entering a new id into the id box. There are two potential efects of this: if you choose a not-yet-used id, the editor will rename the active problem to that new id. This involves erasing the problem stored under the old id and resaving it under the new name (the problem itself is not affected, only moved).

The other case is that you enter the id of an existing problem. This does not overrwrite/erase anything (as long as the active problem has an id other than `changeMe`) and it does not rename anything. Instead it switches the focus from the previously active problem to the probem you just entered. Behind the scened it moves the previously focused problem into the background with all the other background problems, stored by its id (unless that id is `changeMe`, in which case it is just lost), and then fetches the problem under the new id and brings it to focus. You don't have to click the save button after every change you make; the browser holds all the problems with all your changes for the duration of a session.

If for some reason you want to completely erase a problem, you can do so by renaming it to `changeMe`. Do not do this to any problem you care about. The editor ignores any problem with id `changeMe` when either saving or autosaving, so this effectively takes the problem out of the realm of the editor's consideration (i.e. erases it). If you navigate to a different problem now then the problem marked `changeMe` will be lost upon populating the GUI with the named problem's data. Alternatively, clicking the Clear/New Problem button at this point will erase all the data in the `changeMe` problem and it will be no longer retrievable.

# Standalone Problem

You can write problems and save them one at a time. Click the save button and this site will generate a file containing the active problem (TeX for problem, solution, and all the metainformation) and will offer it to you to save somewhere on your computer. This is the simplest way to obtain a single problem file. The downside to this is that you have to manually add the problem id to the `problemsList.txt` file, and then repeat this process with each new problem you write. Only do this if you are getting a feel for how the editor works or if you aren't using it for a problem in a qual repository but an actually standalone problem.

# Problem in a Qual

If you have succesfully initiated a qual on this site and have given the qual some problems, you will want to preload the whole qual page's set of problems before you work on new problems for that qual. Doing this lets the editor help with avoiding name conflicts, populates metainformation lists with the metainformation from all the problems in the qual, and allows downloading the whole folder at once when you are done making your changes. To import a qual, enter the name of your qual in the appropriate input at the top.

When a qual is loaded you can open a saved problem by entering the id into the problem id box. This allows you to modify existing problems. Remember this does not actually affect the site -- you have to change the folder in the master branch on GitHub in order for your changes to actually be made live.

If you want to create a new problem in a qual, click the Clear/New Problem button. This will generate a blank problem with an id of `changeMe`, which you have to change or else your problem will be ignored by the editor. You can create multiple new problems in a session without saving each one independently because the whole list of problems is held by the editor while it is open. Once you have finished your session and are ready to download the new problems all at once (along with all the old problems too), click the Save All button to get a `.zip` folder with all problems in that qual. You have to unzip the folder on your own computer and then put that new folder onto GitHub (or your local version depending on how you opened this website) to make the changes affect the website.

# Local Problems

There is a way to work with auto saving, where each problem is kept stored in browser storage so that they are not lost when you close the window. To do this, enter `local` as the qual name when you begin. This creates and maintains a local repository of questions inside your browser, so you only have to click save when you are ready to use the folder. Enter `local qualName` to initialize the local repository and then load the current set of problems for the corresponding qual.

Autosave is a wonderful thing when it works. As we saw above, the problems are already automatically saved during a browser session. Enabling autosave by using the `local` qualName essentially extends this behavior to persist between browser sessions. You can turn off your computer if you want and the changes will still be saved in the browser's local storage. Just know that this autosave can only go so far -- if you clear your browser's cache/memory (this happens automatically in private/incognito mode) then you will lose any autosaved problems. Also you should test the autosave feature before relying on it. Testing consists of trying it out on just one problem: on a new load, enter `local` to initialize autosave. Enter some stuff into the active problem and rename it to something other than `changeMe`. Close the browser. Reopen it, enter `local` again, and see if you can find the test problem you made. If so then autosave works, and if not then it doesn't.

The erase button for local storage will erase all the locally stored problems from browser memory. It does not erase any actual files (browsers can't do that), it just clears the autosaved data. This feature is for clearing up browser memory without totally resetting the browser memory (which you can do from some setting in your browser), which would also lose some other information you may not want to lose (soft renames, see below).

# Other Browser Storage (Soft Renames)

The bulk of information stored on the browser from this site is from the autosave feature (if utilized). There is another use for browser storage, though, and that is soft renames. These are local versions of options in metainformation, primarily designed for obscuring instructor names. The name in the file is just an id, and you can associate a real name to that id. These associations are stored in your browser's local storage so they are subject to the same rules as the autosave, namely that they only work if browser storage is enabled, that they are not shared between browsers/devices, and that they will be erased upon clearing browser memory. These data are the things we typically want to keep even if we want to clear the problems, hence the clear storage button (which doesn't erase these) is more appealing for clearing browser storage than the browser's memory clearing mechanism (which erases everything) when you are done working on problems.