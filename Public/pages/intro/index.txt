<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" src="pages/intro/intro" trigger="css"/>
        <link rel="stylesheet" src="pages/intro/graphs" trigger="css"/>
    </head>
    <body>
        <div class="title">
            <h1>A New Language</h1>
            <h6>(still coming up with the name for it)</h6>
            <h2>Alec Martin</h2>
        </div>
        <script>/*new GraphBuilder();*/</script>
        <div trigger="section" title="This Project">
            <p>This project is to come up with a language which can accommodate the rigor behind mathematics. The goal is not to make a theorem prover, that is done with functional languages (think C++, Python, etc.). This language does not encode instructions for a processor to execute, i.e. it is not meant to <em>do</em> anything. It is certainly not a natural language  in the sense described below. It is more like a markup language, a technically syntaxed format in which we can express concepts directly as opposed to describing them with words.</p>
            <p>The languages which we people use to communicate to each other will be referred to as natural languages. These encompass spoken English and written English (which are actually quite distinct), as well as the other spoken and written languages of the world, but also languages such as the language of websites which we are using right now in this document. Tools available in the language of websites include links and graphics which do not exist in spoken languages or purely written ones. Note that I am differentiating  the language of the web from HTML itself in that a website is written in HTML but it is read in an interactive environment produced by a browser; we don't have to know how HTML works to read a website. HTML is not a natural language because we don't speak it, we merely use it as a medium in which to speak. Natural landuages generally do not come about in one fell swoop by any one being, instead coming naturally to the members of a culture as a whole so that we can share our experiences and ideas in that culture. We use natural languages to share our ideas as best we can, to try to describe them in such a way as to get other people to understand what we mean.</p>
            <p>To see an example of how natural languages can be extended look at techical writing. Technical documents like user manuals or research articles are full of terms and phrases not used in the languages used by most people. That's not to say most people can't understand them, its just that the terminology and to an extent the structure itself is different. That is because concepts like the rate at which lubricant is pumped through a machine or the molecular mechanism of a particular drug delivery system generally don't apply to the information we wish to share with others. However, when we are faced with the dilemma of not having words sufficient to convey our ideas, the natural, if not necessarily immediate, approach is to come up with new terminology and morph it into our other languages so that we can use mostly familiar structures but with new things to say for new ideas.</p>
            <p>Mathematics follows this same approach but to an extreme. We no longer restrict ourselves to mere words, we allow orselves to invent notations and use them as part of our natural language. Math documents are a wild combination of words which everyone knows interlaced with words, symbols, equations, and diagrams which exist nowhere but in math, and the successful reader will read all the parts as one statement. To a mathematician, the phrase <span math="">Let x=1. Then x+x=2.</span> consists of two perfectly valid sentences, complete with subjects, predicates, and mathematical meaning. However, this is still using natural language to try to describe a mathematical idea which we like to believe exists outside our culture, in some more fundamental level of logic and rigor. We use natural languages because that is how we think, but the goal of this project is to create a language more naturally suited to handle mathematical statements. Think of this language like HTML in the sense previously mentioned, it is a way to encode the meaning of ideas in a particular culture in a way which computers can parse and manipulate.</p>
            <p>What we mean by rigor is not easy to describe rigorously, but we will do our best to develop this language to accomodate sufficient rigor. One idea behind this language is that ambiguity should be eliminated, every single piece of meaning behind a mathematical statement has to be stated. Moreover, a statement cannot be made if it is not stated correctly. If it is not stated correctly then the statement will not compile, which only makes sense when this is viewed as a computer language which actually gets compiled. This website introduces a comiler of the language while simultaneously introducing the language, so compilation does make sense here. Any statement which is successfully stated will include its own assumptions and results, so in a sense it is impossible to give a wrong answer in this language. It may not be the statement we were looking for, but it can't be incorrect or it won't compile. This is one of the several features of the new language which make it suited for math more than our standard natural languages. In our natural language we can easily state something incorrect, like <math><mn>1</mn><mo>=</mo><mn>2</mn></math>, as the burden is on the reader to check for validity. In this language, saying <math><mn>1</mn><mo>=</mo><mn>2</mn></math> is incomplete; it is not a statement. A more complete statement would be the statement "assume <math><mn>1</mn><mo>=</mo><mn>2</mn></math>" or "I claim <math><mn>1</mn><mo>=</mo><mn>2</mn></math>," neither of which is incorrect anymore.</p>
            <p>The ultimate goal of this language is to provide a universal (with respect to computers) medium in which to make mathematical statements. The reasons are potentially vast, if the computer could understand the meaning behind the math then we could write mryiad applications for learning materials, such as interactive homework programs beyond the scope of what is currently possible. This project actually stemmed from an earlier idea of mine of an RPG where the main character runs into dragons and other monsters who throw calculus problems as attacks and we get to answer them with whatever approach we want, saving ourselves with an answer or giving up and running away to some other part of the game world. This game may still be developed in the future, but first the computer has to know whether our answer is correct or not. I thought it would be easier to develop a language where the answer has to be correct to be given instead of writing some algorithm to check if our work is correct, because the intention is that the player can use any approach, even ones not considered by the designer of the game.</p>
            <p>Potential applications could be more serious, too. When publishing an article the author might decide to link the rigorous version of the content, stated in this language, so the computer can display the material in a way which the reader can interact with. If the reader wants to go into more detail in one particular section, or see explicitly what definition is being used, the computer can happily accommodate. The nature of a statement means the reader can ultimately follow every step if they so desire, since the computer actually knows the arguments used, and that is since the arguments are given in a way which shows how they are used. It would be impossible to not be able to understand the work, at least literally, in the same way that it is impossible to not know how a word is spelled when reading the correctly-spelled word in a book. Obviously it will still be possible that the reader can be lost as to the deeper meaning behind what is being said, but a language where the rigorous steps are inherent to the statements will hopefully help people understand our math more than our current language where it is left up to us to try and describe it with words and symbols.</p>
        </div>
        <div trigger="section" title="The Language">
            <p>This language is written in XML. XML stands for eXtensible Markup Language, designed in 1996 for use on the world wide web. It should be easy enough to pick up as we go, that is one of the main design features of XML, but you can read about it from the <a href="https://www.w3.org/XML/">managers</a>, <a href="https://en.wikipedia.org/wiki/XML">wikipedia</a>, or some <a href="https://www.w3schools.com/xml/xml_whatis.asp">tutorials</a> if you would like more information about XML itself. XML is a great language for developing new languages, which is one of its other major design features.</p>
            <p>The base to this whole language is what is known as the <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>. It's a fancy name, but like XML they are simple enough to just pick up as we go. The idea is that there is a collection of nodes (that's the graph part), and each node can have some arrows going out of it to other nodes (the directed part). To avoid problems with cyclic arguments we force that no node can follow a path along sequence of arrows and get back to itself. That makes our graphs acyclic. We cannot allow for cycles because of what we will use the arrows to represent. You cannot specify what a number <math><mi>x</mi></math> is by saying <span math="">Let <math><mi>x</mi></math> be the number <math><mi>x</mi></math></span>. Likewise, circular proofs are not allowed. Below is a circular proof.</p>
            <p math="">Let <math><mi>x</mi></math> and <math><mi>y</mi></math> be numbers. Assume that <math><mi>x</mi><mo>=</mo><mi>y</mi></math>. Because <math><mi>x</mi><mo>=</mo><mi>y</mi></math>, we get that <math><mi>y</mi><mo>=</mo><mi>x</mi></math>. Now because <math><mi>y</mi><mo>=</mo><mi>x</mi></math>, we get that <math><mi>x</mi><mo>=</mo><mi>y</mi></math>. Thus <math><mi>x</mi><mo>=</mo><mi>y</mi></math>.</p>
            <p>This is not a proof because it doesn't depend on the values of <math><mi>x</mi></math> and <math><mi>y</mi></math>. That proof is exactly the same when proving that <math><mi>1</mi><mo>=</mo><mi>1</mi></math> and also that <math><mi>1</mi><mo>=</mo><mi>2</mi></math>. We will avoid all cycles in this language to avoid fallacies of circular arguments. We will also eventually have the feature that the nodes can be typed, meaning they have a particular type they must match, but we will get into that later. The general directed acyclic graph model is the backbone to all statements made in this language, along with all the ways they can be connected into theories or used as lemmas in other statements. Also, a note to those who like infinity: all of our graphs are finite (meaning finitely many nodes), but once the language is developed we can use it to talk about all the infinities you could ever want.</p>
            <p>Each statement made in this language is stored in a separate XML file. That file is parsed by the compiler and if it passes the various tests performed by the compiler, the statement is stored and can be referenced by other statements (in an acyclic manner, of course). Statements come in the form of definitions which define the types of objects we are working with, lemmas which are how we make claims in this language and how we use those claims, proofs which are justifications of lemmas which rely on other lemmas, and potentially some other types. Also there are some special configuration files which help make it easier to write the XML files, keeping them less verbose. The hope is that, although every statement will exist in full detail, we should not be putting full detail into each XML file. There are lots of pointers to other, previously written files which so we can link together our work and not rewrite it every time.</p>
            <p>One key thing to keep in mind is that this language is explicitly for <em>relative</em> proof. We will not be pursuing absolute truth, and we will not be trying to eliminate all axioms. Not only has this goal been <a href="https://plato.stanford.edu/entries/goedel-incompleteness/">proven</a> to be impossible in general, it is not necessary for mathematics. We are not so much interested in which statements are true as we are in how some assumptions force others to be true in certain contexts, and how that forcing is performed. We will get back into this when we talk about proofs.</p>
        </div>
        <div trigger="section" title="Primary Example">
            <p>We are going to use a simple lemma from algebra as our primary example. Here is the lemma written in our natural language of math, written English with symbolic manipulation, spiced up with some HTML to organize it all.</p>
            <div trigger="direct" src="pages/intro/writtenProof"/>
            <p>If you have never read a proof in abstract algebra then it might not make sense what we are doing, but any full introduction to algebra will contain this material. <a href="https://www.mathsisfun.com/sets/groups-introduction.html">Here</a> is a not full introduction which you may want to check out just to get the hang of how algebra works at this level.</p>
            <p>Our goal now is to state and prove this lemma in our new language. We will look at the statement now, but don't expect any of it to make sense just yet. The point of putting it here is so that you have something to visualize while reading the rest of the sections. Go ahead and play around with the viewing tool, the nodes are interactive. You can change their color with the color chooser and also their position by dragging them around. The colors are randomly generated and sometimes some colors can be quite similar to others so it can be hard to tell them apart. That's why there is an option to change the colors.</p>
            <div src="Set/lemmas/inverseIsUnique" trigger="GraphViewer"/>
            <p>Note that the connecting lines are oriented with the thicker part at the source of the arrow and the thinner part at the destination of the arrow. Parts to look for are that the nodes are each colored and the nodes of the same color have the same number of arrows coming out of them. The colors are associated to the types of the elements, we will see what that means in the next section. Also each node has an id which is displayed when the element is hovered over by the mouse. Also notice that one node has a different shape than the rest. The shapes are from something called assumption levels which is more advanced and which we will see a few sections later.</p>
        </div>
        <div trigger="section" title="Definitions">
            <p>The way definitions and phrases work is very intertwined, causing a bit of a cyclic chicken-and-egg problem. There is a mechanism in place to keep it from being a true cycle (remember we abhor those, everything is acyclic), but the technical description for why this approach is ok would take us out of the scope of this language and into the realm of <a href="https://www.mathsisfun.com/algebra/mathematical-induction.html">induction</a>. If you are not used to math and proofs, you may want to check out that link for the sake of being introduced to some more concepts, hopefully familiarizing yourself a little more with how we think in mathematics. That link is particularly good with how and when we use assumptions. We don't need to bring the actual material here, though, because this is just a light introduction to the language.</p>
            <p>The purpose of a definition is that a definition is a shape, a particular shape that a portion of a graph must have. For some terminology, we use the word "phrase" to refer to the graph itself, the nodes and arrows, which represent the mathematical statement as a whole. We also call that statement the phrase. We use the words "term" and "node" somewhat interchangeably, terms are on the mathematical meaning side and nodes are on the graph side but they mean the same thing. We also can call terms "objects," "elements," or "vertices." The word "child" refers to the arrows coming out of a node, or to the node at the other end of the arrow. To differentiate between the various arrows which can be coming out of a single node, we name the arrows. We call that naming the children. There is a difference between the child's name and the child node and this will be important when we start making definitions. Parents are nodes who have arrows pointing to children. Note that because the graphs are acyclic, no element can be its own ancestor (which is a good thing). We use the word "definition" to mean the shape that a node has to follow to be an object of that type, shape meaning a description of what children an element must have and how they must be oriented. We will see how that works soon. Definitions are given by phrases, and phrases use definitions to give meanings to the terms, so this is the chicken-egg problem.</p>
            <p>Let's look at the definition of a binary operation. We are not looking at the properties of a binary operation, just the object itself. A binary operation is defined on a set, and that is all the context it needs. We encapsulate that by saying a binary operation has a single child, that child is a set, and that child's name is "on." This is the shape a binary operation has to have to be a valid binary operation. That information is stored in the binary operation definition, then any time we say that an element is a binary operation we have to construct it with the structure in the definition, namely we have to give our element a child named "on" which is a set. All the information about what it means to actually be a binary operataion, besides just being defined on a set, will come in later files.</p>
            <p>The way we declare a definition is to create a phrase with all the context used in that definition. In the example above, we create the phrase <span math="">Let <math><mi>on</mi></math> be a Set.</span> That is the end of our definition declaration, let's look at what the compiler does with it. Upon reading any phrase (including this definition) the compiler will cap the graph with a new node. Specifically it looks for all maximal elements and sets those as the children of the cap node. The name of the element, given in the phrase, is used as the child name for the cap. That means that our set, named "on," becomes the child of the cap and its name is "on." This means that the type which the cap defines (binary operation) must have a child named "on" which matches the shape given in the phrase. The shape in this case is just that the child is a Set. Though not relevant to this example, we can further name the cap or otherwise alter it by giving attributes directly to the root node, though this is not necessary in general. Note that we must have already defined Set in order to state the definition of Binary Operation.</p>
            <p>We can now look at the definitions of all the elements used in the statement of the lemma which is our prime example. First let's see the simple definitions.</p>
            <div class="dropList">
                <details>
                    <summary>Set</summary>
                    <p>Sets are defined, and that is it. There is no other context required to define a set in this interpretation. In one sense this is the simplest definition, but that does not make it any less confusing. If you don't want to get into technical subjective stuff about existence without any context then feel free to skip to set elements.</p>
                    <p>In the interpretation of set theory used by this lemma, sets exist given no other context. Note that this does not mean that any set in the usual sense exists, if you know of <a href="https://plato.stanford.edu/entries/russell-paradox/">Russel's paradox</a> then your contradiction alarm bells might be ringing. The way this interpretation works is that the information about a set, like what types of elements it contains, comes after the set has already been established. Even though any set is equivalent to any other at this point, we do not yet have enough developed to say anything about sets. All they do is exist. It may be a strange way of looking at things compared to normal set theory but this is the starting point for definitions, the base case of our chicken-egg induction if you will. You have to have something defined on nothing and here we choose it to be sets. We are totally allowed to choose a different starting point, by the way. Sets as the first definition is not a universal choice, it is merely convenient for this lemma.</p>
                    <div src="Set/definitions/Set" trigger="GraphViewer"/>
                </details>
                <details>
                    <summary>Set Element</summary>
                    <p>A set element is an element of a set, so it is defined with one child, named "of," which is a set. Remember the naming comes from the id of the term in the phrase so the set is given the id "of." Once this definition has been established we can talk about the elements of sets, wheras before we could only talk about the set itself. Note that in this interpretation it is possible for a set to have several elements but any element belongs to one and only one set. If you know about <a href="https://mathinsight.org/definition/subset">subsets</a> and the like, we can't talk about that with only the two definitions so far. We would need more context (more definitions) for that level of language functionality.</p>
                    <div src="Set/definitions/SetElement" trigger="GraphViewer"/>
                </details>
                <details>
                    <summary>Binary Operation</summary>
                    <p>A binary operation is taken to be on a set, so it is defined with one child, named "on," which is a set. Binary operations have the additional property of being well-defined as we saw in the "primary example" section. That property will come later, for now we are only saying what we want a binary operation to be and we want it to be something defined on a set. How to deal with properties will be covered in a later section of this page.</p>
                    <div src="Set/definitions/BinaryOperation" trigger="GraphViewer"/>
                </details>
            </div>
            <p>The way context in this language works is that context, such as additional properties a particular given element might have, is given by higher, more parent-side terms in the graph representing our statement. That means these definitions are actually somewhat abstract to understand, being definitions of properties, but we define them concretely as object types and here are the definitions. Again the actual properties which we desire to represent with these objects will come later.</p>
            <div class="dropList">
                <details>
                    <summary>Associative Binary Operation</summary>
                    <p>A binary operation may be associative. The way we state a binary operation is associative is not to say anything about the operation itself, but instead to create a new element, the associative binary operation element, which has a child named "this" who is the binary operation we are stating is associative. This is in general how we add properties to elements, by setting them as children of a higher type of element which represents the property. When we want to refer to the fact that the operation is associative, we will refer to this associative binary operation element as opposed to the binary operation directly.</p>
                    <p>Note that our binary operation, in order to match its own definition (given above), must be defined on a set. That is why there are three nodes in this graph instead of just two.</p>
                    <div src="Set/definitions/AssociativeBinaryOperation" trigger="GraphViewer"/>
                </details>
                <details>
                    <summary>Identity</summary>
                    <p>An Identity element is an object which knows that some given Set Element is an identity under some given Binary Operation. Note that this only makes sense if both are defined over the same Set, that is why the graph in this definition converges to the same point at the bottom. An Identity must have two children, one named "this" which is a Set Element and one named "under" which is a Binary Operation, and both must be defined on the same set. If we want to refer to the fact that some element is an identity, we refer to the Identity node. If we want to refer directly to the set element itself then we can refer to the node which is the "this" child of the Identity node, but doing so ignores that the element is an identity.</p>
                    <div src="Set/definitions/Identity" trigger="GraphViewer"/>
                </details>
                <details>
                    <summary>Inverse</summary>
                    <p>Inverse is more complicated still. To store all the information about what an inverse is, we need two Elements and an Identity. The two Elements are called "this" and "of," the idea being that the Inverse element adds context to "this" and represents an inverse of "of." The Identity child, called "identity," gives context as to which Identity, which itself knows the identity Element and the Operation, is used in the inverse property. Any time we create an Inverse element we have to set up its children, "this," "of," and "identity," to look like those in the graph here.</p>
                    <div src="Set/definitions/Inverse" trigger="GraphViewer"/>
                </details>
                <details>
                    <summary>Equality of Set Elements</summary>
                    <p>This is simpler than the last few. An Equality is an object which knows that two Set Elements are equal. The Elements are called "first" and "second," and they have to be defined on the same Set. Until this point we had no way of comparing two elements of the same set. Now we have the ability to say that two elements are equal. We don't have any concept of what it means to be equal other than that there is an Equality term which has two two elements as children, any meaning behind equality will be given in later files. Also we still don't have any way of saying that two elements are not equal.</p>
                    <div src="Set/definitions/EqualityOfSetElements" trigger="GraphViewer"/>
                </details>
            </div>
            <p>Though we don't need it to state our lemma, we also will use one more definition, the applied binary operation, in the proof.</p>
            <div class="dropList">
                <details>
                    <summary>Applied Binary Operation</summary>
                    <p>This one may be the most complicated of the definitions so far. When we combine two set elements using a binary operation, we get another set element. We have to keep in mind the two inputs, the operation, and the result when we do this. The Applied Binary Operation object has children named "first" and "second," Set Elements, which represent the inputs. The Applied object also has a child named "operation" which is the Binary Operation, and a Set Element named "this" which represents the result of the combination.</p>
                    <p>There are two elements here, the "this" and the cap, which have different assumption levels than all the other terms we have seen so far. We haven't learned about assumption levels yet, but that is what is causing the difference in shape and also in the words section. We will get back to assumption levels after seeing how to make basic phrases first.</p>
                    <div src="Set/definitions/AppliedBinaryOperation" trigger="GraphViewer"/>
                </details>
            </div>
        </div>
        <div trigger="section" title="Basic Phrase (and file)">
            <p>In this section we will see how to make a file which represents a mathematical phrase. We want a basic phrase, i.e. a phrase with no proofs or steps or anything, just background setup. Our phrase will encapsulate this statement:</p>
            <p math="">Let <math><mi>X</mi></math> be a set. Let <math><mi>x</mi></math> and <math><mi>y</mi></math> be elements of <math><mi>X</mi></math>, and let <math><mo>op</mo></math> be a binary operation on <math><mi>X</mi></math>.</p>
            <p>We are going to be using the definitions of Set, Element, and Binary Operation given in the previous section.</p>
            <p>This is going to be saved in an XML file. These files are written in text and have certain syntaxes in order to form an XML document. XML documents are series of elements nested in each other, where elements are given by tags which open and close the element. To start, let's make the element which says this is a basic phrase. Our file starts like this:</p>
            <details class="xmlFile">
                <summary>necessary XML creation syntax</summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase&gt;</p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p>The first line is a file formatting line, we can just ignore what it does as long as we put it in every file we write. The second line opens an element whose name is "basicPhrase" and the third line closes it. The basicPhrase node is called the root node because it is the outermost node in the file. Every XML document needs a single root node and ours will be basicPhrase. This is just syntax required for an XML file, the next step is the first real step in the new language.</p>
            <p>Before we can talk about particular elements and how they should be set up, we need to define the types we will be working with. We do that in the requiredURIs section of the file, which must be the first child of the root. The requiredURIs section is how we refer to external, previously defined work. In this case the external work is the definitions of Set, Element, and Binary Operation. We need to simultaneously name these definitions and give the locations of the files which make up the definitions. The sytax here is to set the name as the "id" attribute and to set the location as the innards of the elment. The file with the requiredURIs section complete looks like this:</p>
            <details class="xmlFile">
                <summary>building on previous work</summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase&gt;
                    <p>&lt;requiredURIs&gt;
                        <p>&lt;definition id="Set"&gt;Set/definitions/Set&lt;/definition&gt;</p>
                        <p>&lt;definition id="Element"&gt;Set/definitions/SetElement&lt;/definition&gt;</p>
                        <p>&lt;definition id="BinOp"&gt;Set/definitions/BinaryOperation&lt;/definition&gt;</p>
                    </p>
                    <p>&lt;/requiredURIs&gt;</p>
                </p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p>When the compiler reads the requiredURIs section, the three nodes with the name "definition" are interpreted as definitions of types which will be used in the later statement. Note that at this stage the compiler doesn't actually care that the element is declared as a definition. It is only opening files and giving them names. Actually the declaration of these files as definitions won't affect anything until much later in the development of this language; we can successfully state and prove our lemma that inverses are unique without ever reading the tag names of the elements in the requiredURIs section. The locations of the definitions are given by the contents of these nodes, that is the file directory portion, and the "id" attribute declares what we will call these types. Later we will see that definition is not the only type of external file we can use here, but because this is a basic phrase we only need definitions.</p>
            <p>The requiredURIs tag has a special role more than just pointers. The compiler will open the files in the given directories and compile them first, before ever looking at the contents of this file. That means that every definition we are declaring must be correctly written, because if not then the compiler will throw an error and stop before it even starts the actual content of this phrase. The files referenced may reference external files of their own and the compiler will continue opening and checking every piece referenced in the requiredURIs section until it has read all of it. Then it will come back and do what we say in this current file. This is another example of why we require acyclic structure -- we don't want our compiler to get stuck in a loop.</p>
            <p>After the requiredURIs section comes the meat of our statement. The way we declare that is by opening a "statements" node which will house our statements. That means our file now looks like this:</p>
            <details class="xmlFile">
                <summary>opening the statements</summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase&gt;
                    <p>&lt;requiredURIs&gt;
                        <p>&lt;definition id="Set"&gt;Set/definitions/Set&lt;/definition&gt;</p>
                        <p>&lt;definition id="Element"&gt;Set/definitions/SetElement&lt;/definition&gt;</p>
                        <p>&lt;definition id="BinOp"&gt;Set/definitions/BinaryOperation&lt;/definition&gt;</p>
                    </p>
                    <p>&lt;/requiredURIs&gt;</p>
                    <p>&lt;statements&gt;</p>
                    <p>&lt;/statements&gt;</p>
                </p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p>Our first statement has nothing to be defined on, so it has to be of a type which can be defined on nothing. That is, it has to be a Set. We want a set called <math><mi>X</mi></math>, we do this by creating an element with the name of Set and an id attribute of "X." Note that this is going to be a self-closing tag because it has no children, that is another piece of XML syntax.</p>
            <details class="xmlFile">
                <summary>creating <math><mi>X</mi></math></summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase&gt;
                    <p>&lt;requiredURIs&gt;
                        <p>&lt;definition id="Set"&gt;Set/definitions/Set&lt;/definition&gt;</p>
                        <p>&lt;definition id="Element"&gt;Set/definitions/SetElement&lt;/definition&gt;</p>
                        <p>&lt;definition id="BinOp"&gt;Set/definitions/BinaryOperation&lt;/definition&gt;</p>
                    </p>
                    <p>&lt;/requiredURIs&gt;</p>
                    <p>&lt;statements&gt;
                        <p>&lt;Set id="X"/&gt;</p>
                    </p>
                    <p>&lt;/statements&gt;</p>
                </p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p>At this point in our phrase we have established the set <math><mi>X</mi></math>. Next we will create the two Set Elements <math><mi>x</mi></math> and <math><mi>y</mi></math>. We do this with nodes whose names are "Element" because that is what we decided to call the definition of a Set Element in the requiredURIs section. Being Set Elements, they must match the definition of Set Element. That is, they need a child named "of" which is a Set. We want that set to be <math><mi>X</mi></math>, this is how we manage that:</p>
            <details class="xmlFile">
                <summary>creating <math><mi>x</mi></math> and <math><mi>y</mi></math></summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase&gt;
                    <p>&lt;requiredURIs&gt;
                        <p>&lt;definition id="Set"&gt;Set/definitions/Set&lt;/definition&gt;</p>
                        <p>&lt;definition id="Element"&gt;Set/definitions/SetElement&lt;/definition&gt;</p>
                        <p>&lt;definition id="BinOp"&gt;Set/definitions/BinaryOperation&lt;/definition&gt;</p>
                    </p>
                    <p>&lt;/requiredURIs&gt;</p>
                    <p>&lt;statements&gt;
                        <p>&lt;Set id="X"/&gt;</p>
                        <p>&lt;Element id="x"&gt;
                            <p>&lt;of&gt;X&lt;/of&gt;</p>
                        </p>
                        <p>&lt;/Element&gt;</p>
                        <p>&lt;Element id="y"&gt;
                            <p>&lt;of&gt;X&lt;/of&gt;</p>
                        </p>
                        <p>&lt;/Element&gt;</p>
                    </p>
                    <p>&lt;/statements&gt;</p>
                </p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p>Every time the compiler reads a term in the statements section it performs a test to see if that term matches the definition it of the type it claims to be. Matching the definition of Set is trivial because there is nothing to test, but it is not trivial for Set Elements. If we had not given the nodes named "of," or if we had misspelled the word "of," or if the contents of the "of" node were not the id of a previously defined term, or if they were a term but that term were not of the type Set, then the compiler would throw an error. This is why it has to process the definitions files first, and is also one of the design features which make it impossible to say anything incorrectly.</p>
            <p>The last thing we need to do is add the Binary Operation and we will have completed our basic phrase. We can also name the cap node which the compiler puts on every phrase, let's name it "phrase." Below is the finished phrase.</p>
            <details class="xmlFile">
                <summary>full phrase</summary>
                <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p>
                <p>&lt;basicPhrase id="phrase"&gt;
                    <p>&lt;requiredURIs&gt;
                        <p>&lt;definition id="Set"&gt;Set/definitions/Set&lt;/definition&gt;</p>
                        <p>&lt;definition id="Element"&gt;Set/definitions/SetElement&lt;/definition&gt;</p>
                        <p>&lt;definition id="BinOp"&gt;Set/definitions/BinaryOperation&lt;/definition&gt;</p>
                    </p>
                    <p>&lt;/requiredURIs&gt;</p>
                    <p>&lt;statements&gt;
                        <p>&lt;Set id="X"/&gt;</p>
                        <p>&lt;Element id="x"&gt;
                            <p>&lt;of&gt;X&lt;/of&gt;</p>
                        </p>
                        <p>&lt;/Element&gt;</p>
                        <p>&lt;Element id="y"&gt;
                            <p>&lt;of&gt;X&lt;/of&gt;</p>
                        </p>
                        <p>&lt;/Element&gt;</p>
                        <p>&lt;BinOp id="op"&gt;
                            <p>&lt;on&gt;X&lt;/on&gt;</p>
                        </p>
                        <p>&lt;/BinOp&gt;</p>
                    </p>
                    <p>&lt;/statements&gt;</p>
                </p>
                <p>&lt;/basicPhrase&gt;</p>
            </details>
            <p><a src="pages/intro/basicPhraseNoViewings" trigger="internal link">Here</a> is the actual phrase stored in an actual XML file, and below is the same phrase but with a simple XML file rendering tool.</p>
            <div src="pages/intro/basicPhraseNoViewings" trigger="xmlFile and GraphViewer"/>
            <p>As you can see, the graph viewer doesn't look very good because it puts each node in the same corner. We can add some information about positioning to get it to open with a graph we can see. We don't need to go into details as to how the positioning works in part because the format will probably keep changing as the language gets developed. <a src="pages/intro/basicPhrase" trigger="internal link">Here</a> is the file with the viewing information and below it is rendered preformatted. After dragging and dropping the nodes into good places you can hit the save button on the viewer and a window will pop up with text formatted to store this positioning information.</p>
            <div src="pages/intro/basicPhrase" trigger="xmlFile and GraphViewer"/>
            <p>We have successfully made a mathematical statement in this new language. There is not much we can do in math with purely basic phrases, but we can now set up the necessary context to make interesting statements later on.</p>
        </div>
        <div trigger="section" title="Dictionaries">
            <p>This is a little piece of syntactic sugar, meaning it is just a shortcut and doesn't add fundamental features. We don't need to go into it now (or technically ever) but the files written later on use this mechanism and we might as well see how it works. The goal of dictionaries is to keep the length of the requiredURIs section to a manageable size. We can store a collection of declarations in a separate file, called a dictionary, then import the dictionary into our file and use the declarations. For example, check out the dictionary <a src="Set/dictionaries/ElementsAndEquality" trigger="internal link">Elements and Equality</a>.</p>
            <div src="Set/dictionaries/ElementsAndEquality" trigger="xmlFile"/>
            <p>This dictionary contains the definitions of Set, Set Elements, and Equality of Set Elements along with the properties which equality follows. We will get into those properties later. Right now we are only interested in the declarations of the files and their reference names. When we want to use these words (Set, Element, and Equality) without redeclaring them we can simply add the dictionary in the requiredURIs section. The compiler essentially copies the contents of the dictionary file and places them into the file it is compiling, continuing as normal from there. With this information we can understand almost every part of all of the definitions used by our lemma, those are given below. The only part we haven't covered is in the Applied Binary Operation definition and that is because that file is used simultaneously as a definition and a lemma, and we haven't seen lemmas yet. What we have seen is how to make a basic phrase and how the compiler turns that into a definition, allowing us to build up a series of definitions into a body of work which we can conveniently reference with dictionaries.</p>
            <div class="dropList">
                <details class="allBlock">
                    <summary>definitions</summary>
                    <a src="Set/definitions/Set" trigger="internal link">Set</a>
                    <a src="Set/definitions/SetElement" trigger="internal link">Set Element</a>
                    <a src="Set/definitions/BinaryOperation" trigger="internal link">Binary Operation</a>
                    <a src="Set/definitions/AssociativeBinaryOperation" trigger="internal link">Associative Binary Operation</a>
                    <a src="Set/definitions/Identity" trigger="internal link">Identity</a>
                    <a src="Set/definitions/Inverse" trigger="internal link">Inverse</a>
                    <a src="Set/definitions/EqualityOfSetElements" trigger="internal link">Equality of Set Elements</a>
                    <a src="Set/definitions/AppliedBinaryOperation" trigger="internal link">Applied Binary Operation</a>
                </details>
            </div>
            <p>These definitions are grouped together in the dictionary <a src="Set/dictionaries/BinaryOperation" trigger="internal link">Binary Operation</a>, along with the defining properties which again we haven't covered yet.</p>
            <div src="Set/dictionaries/BinaryOperation" trigger="xmlFile"/>
        </div>
        <div trigger="section" title="Assumption Levels">
            <p>The idea behind assumption levels is more technical than that behind definitions and basic phrases. In a general phrase we may want to differentiate between which terms are assumed and which are not assumed. We are going to talk about lemmas and proofs. This section focuses on lemmas, but the only reason we care about lemmas is that we can use them in proofs, so we will be mentioning proofs quite a bit too. The more complete treatment of proofs comes in a later section.</p>
            <p>First let's acknowledge that there is a difference between a basic phrase and a lemma. A basic phrase is just some terms without any dependence or theory going on. We need basic phrases for context but they don't make for very interesting mathematics on their own. A lemma is the recognition that some statements follow from other statements. This is where math starts to get interesting. For a simple example, suppose we are just working with numbers. Take the statement below.</p>
            <p math="">Let <math><mi>x</mi></math>,<math><mi>y</mi></math> be numbers. Assume that <math><mi>x</mi><mo>=</mo><mn>1</mn></math> and <math><mi>y</mi><mo>=</mo><mn>2</mn></math>. Then <math><mi>x</mi><mo>+</mo><mi>x</mi><mo>=</mo><mi>y</mi></math>.</p>
            <p>You have probably seen variables used in math classes before, especially in algebra classes. Here we are not really using them as variables. We are assuming that <math><mi>x</mi></math> is just the number <math><mn>1</mn></math> and that <math><mi>y</mi></math> is <math><mn>2</mn></math>. That means we don't want to solve for <math><mi>x</mi></math> or <math><mi>y</mi></math>, we already know what they are because we assumed their values. The term we want to focus on is the final term, the statement that <math><mi>x</mi><mo>+</mo><mi>x</mi><mo>=</mo><mi>y</mi></math>. We don't want to say that we are assuming <math><mi>x</mi><mo>+</mo><mi>x</mi><mo>=</mo><mi>y</mi></math>, we want to say that we already know <math><mi>x</mi><mo>+</mo><mi>x</mi><mo>=</mo><mi>y</mi></math>, that this comes from the previous assumptions.</p>
            <p>We will differentiate between the previous terms and the equals term by giving every term in our phrase an assumption level. The two equality terms <math><mi>x</mi><mo>=</mo><mn>1</mn></math> and <math><mi>y</mi><mo>=</mo><mn>2</mn></math> will be given an assumption level of "assumed." There are lots of background terms too; interpreting this in our new language would involve creating terms for <math><mi>x</mi></math>,<math><mi>y</mi></math>,<math><mn>1</mn></math>,<math><mn>2</mn></math>, and <math><mi>x</mi><mo>+</mo><mi>x</mi></math> (and probably even for <math><mo>+</mo></math> and <math><mo>=</mo></math>, too). All of these terms need an assumption level, and we deal with this by defaulting to "assumed." The only term which does not have the assumption level of "assumed" is the equality term, <math><mi>x</mi><mo>+</mo><mi>x</mi><mo>=</mo><mi>y</mi></math>. This term will be given the assumption level of "freebie," which means that this term comes for free given the previous assumptions.</p>
            <p>That wasn't a very interesting lemma, though, because we all know how to add <math><mn>1</mn></math> to itself. Let's go back to our main example, the lemma that inverses are unique.</p>
            <div src="Set/lemmas/inverseIsUnique" trigger="xmlFile and GraphViewer"/>
            <p>We should be able to understand, through the material in the previous sections, every part of the <a src="Set/lemmas/inverseIsUnique" trigger="internal link">file</a> except for the attribute on the Equals term,</p>
            <div class="xmlFile">
                <p>&lt;Equals id="aI1EaI2" freebie=""&gt;</p>
            </div>
            <p>The "freebie" attribute is how we declare which terms we want to designate as coming for free given the rest of the assumptions. Any term named as a freebie has its assumption level changed from "assumed" to "freebie." You can see the assumption levels in the graph viewer. The assumption level determines the shape of each dot, in the same way that the type determines the dot's color.</p>
            <p>Let's look more carefully at what just happened. Technically, the assumption level of "freebie" is a claim. By marking a term as a freebie, we are <em>claiming</em> that it comes for free given the rest of the assumptions. There are no checks performed when marking something as a freebie because the compiler cannot tell if that term actually comes from the other terms or if it is an erroneous claim. Remember the compiler is not a theorem prover, it is a theorem stater (and a stater of other aspects of mathematics as well). In other words, we are allowed to claim anything we want as long as the language of our claim is consistent.</p>
            <p>We said earlier that truth is inherent in this language and this is a good time to recall that. Suppose we want to say that <math><mn>1</mn><mo>=</mo><mn>2</mn></math>, which is generally understood to not be correct. When we make the term <math><mn>1</mn><mo>=</mo><mn>2</mn></math>, it defaults to assumed. At this point we are saying that we assume <math><mn>1</mn><mo>=</mo><mn>2</mn></math>. Now, we know that statement is not true (if we are talking about integers, at least). However, we said it is true. The way to make sense of this situation is to consider not absolute truth but relative truth. In the context of this phrase, if somebody asks us "why is <math><mn>1</mn><mo>=</mo><mn>2</mn></math> true?" we can answer with "we assumed it to be true." We do not need to justify our assumptions, we just have to state them clearly and own up to them if they cause problems down the road. Once we change the assumption level to freebie, we no longer have to answer their question at all. If they ask why <math><mn>1</mn></math> equals <math><mn>2</mn></math> we can answer with "we don't even know if it is true. We are merely claiming that it is true." The point in math is to then prove the claim, the idea being that if we can't state a proof then the lemma shouldn't be considered valid. That aspect of mathematics is beyond the scope of this section though, we are mostly trying to understand what a claim is right now.</p>
            <p>How we ultimately want to deal with erroneous claims and contradictions is something still being developed, for now they don't break the language and that is all we care about so far. In fact, for now we don't even have a mechanism to say that something is not true so there really isn't a way to properly state a contradiction. With what we have seen so far, the only way to break the language is to try to create an element which doesn't match its definition. In that case it simply won't compile, however, which is what we mean when we say that nothing incorrect can be stated in this language. Now back to the lemma about uniqueness of inverses.</p>
            <p>Let's run through the compilation of our lemma. The requiredURIs section contains the external files which are all the definitions used by this lemma. The statements section contains the various statements used in the setup of this lemma. If you haven't checked it out already, open the words section of the graph viewer above to see an emulation of our natural math writing. That was written by the computer after reading the file. At this point we have created all the nodes and arrows in the graph and have checked that every term matches the definition it claims to match. We have also set each term's assumption level to "assumed" unless it has the freebie attribute, in which case we set it to "freebie." That is, we have now built the graph which is displayed in the viewer.</p>
            <p>Our compiler will now do some interpretation of the lemma. What it does is run through every term (forgetting the cap for now) and gather all maximal terms which are not designated to be freebies. This is called gathering the assumption maxes. In this example, our assumption maxes are the associative element "ass," the first inverse element "aInv1," and the second inverse element "aInv2." The assumption maxes are remembered by the compiler.</p>
            <p>In a later file, when we use this one as a lemma, we apply the lemma by building an element which matches the cap in this file. That means we declare which terms play the role of the plain maximal elements "ass," "aInv1," "aInv2," and "aI1EaI2." The compiler performs the same test as in the definition case to make sure that the elements we gave contain the same cross-linking structure declared in this file. After that test passes, the compiler will do some manipulation of assumption levels. In the later file the compiler will change the assumption level on the term which was fed as "aI1EaI2" to "proved." In doing so, the compiler will record that this particular step was proven by the lemma we are defining now and that the terms required in the proof were the ones playing the roles of the assumption maxes. The reason it records this information is so it can link together the different proof steps into another graph, the proof graph, which it maintains to make sure we don't try to get away with any circular proof arguments. The assumption max process is how we ensure our proofs are valid. Like trying to create an element which doesn't match its definition, trying to apply a lemma to prove something in a way which generates a circular argument will result in the compiler throwing an error and stopping.</p>
            <p>At this point we can go back to the one special definition, Applied Binary Operation, and discuss why the two nodes "this" and the cap "applied" are freebies. This is somewhat more confusing than the simple application of lemma and proof which is the main example of this website, that inverses are unique, so feel free to skip over this paragraph especially on your first reading. The idea here is that the very assumption of having a binary operation proves that any pair can be combined, so we put the justification into the definition of the combination. We are using the file both as a lemma and a definition. Recall that the compiler does not differentiate between definitions and lemmas when building the graph representing the phrase. The designations of definition vs lemma are intended to be used when we look at how several proofs combine, but we aren't there yet. The presence of freebie terms in the definition of Applied Binary Operation means that every time we make an Applied Binary Operation it will be immediately proven. The lemma which did the proving is the definition of Applied Binary Operation and the terms which were required (the assumption maxes) were the ones playing the roles of "first," "second," and "operation." Both the terms playing "this" and "applied" will be proven using that information.</p>
        </div>
        <div trigger="section" title="Proofs">
            <p>Proofs are essential in mathematics. They are also a source of much confusion in people learning mathematics. One of the main purposes of this project is to create a language where the proof of a statement is part of the statement, as opposed to the natural approach where we use our language to describe a proof. If the proof is part of the statement then there is no need to check if the proof is correct because the correctness of the proof is inherent in its statement. This language may not make it easy for people to learn about proofs, but at least it provides a complete definition for (an interpretation of) what proof is.</p>
            <p>Everyone agrees that <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math>, the truth of this statement is not really up for debate. However, if you ask why <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math>, finding an answer beyond "it just is" is incredibly difficult. Anyone can interpret the reason differently and it would be hopeless to judge who can find the right answer and who is wrong. In the new language, we are not going to worry about absolute truth. We are instead going to focus on relative truth, how some statements are true given that other statements are assumed to be true. The question of "is one plus one two?" will not be something we can answer, at least not without more context. If that context includes that we already know how numbers work, then we can say one plus one is two because that's how numbers work. If we are trying to build numbers from scratch, however, then how we answer whether <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math> will depend on our precise definitions of one, two, plus, and equals.</p>
            <p>To see a proof in action, first assume that <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math> and <math><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></math> (also assume that addition is an associative binary operation and that equality is an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>). We are going to use those assumptions to see what <math><mn>2</mn><mo>+</mo><mn>1</mn></math> is.</p>
            <p>This is the point where proofs become technical. Of course we know that <math><mn>2</mn><mo>+</mo><mn>1</mn></math> is <mn>3</mn>, just as much as we know that <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math> and <math><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></math>. This approach of just knowing the answer is not a proof, though. We are trying to <em>show</em> <math><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></math>, the response "it just is" is not sufficient because it doesn't show anything.</p>
            <p>We need to bring it to our assumptions, which are that <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math> and <math><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></math>. Here is how we can do that:</p>
            <p math="">Start with <math><mn>2</mn><mo>+</mo><mn>1</mn></math>. First, by assumption, <math><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn></math>. Thus <math><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mfenced separators=""><mn>1</mn><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mn>1</mn></math>. Next, because addition is associative, <math><mfenced separators=""><mn>1</mn><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>+</mo><mfenced separators=""><mn>1</mn><mo>+</mo><mn>1</mn></mfenced></math>. Now we use again that <math><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></math> to obtain <math><mn>1</mn><mo>+</mo><mfenced separators=""><mn>1</mn><mo>+</mo><mn>1</mn></mfenced><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn></math>, which is <math><mn>3</mn></math> by our other assumption. That proves that <math><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></math>.</p>
            <p>Again, we are not interested in the absolute truth of the statement <math><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></math>. What we are trying to focus on here is how we can combine assumptions to show that one statement can be forced to be true if some other statements are assumed to be true.</p>
            <p>Writing proofs involving numbers in this new language is actually more difficult than writing proofs in general algebra because we need fully rigorous definitions of numbers and those are very technical. It will actually be easier for us to follow the proof of the main example, inverses are unique, than to continue with this number example.</p>
            <p><a src="Set/lemmas/inverseIsUnique" trigger="internal link">Here</a> is the statement of the inverses-are-unique lemma again. Below is the graph rendering of it.</p>
            <div src="Set/lemmas/inverseIsUnique" trigger="GraphViewer"/>
            <p>Now let's look at the proof. The proof actually relies on another lemma, <a src="Set/lemmas/cancel" trigger="internal link">cancel</a>, which is more complicated and more elementary. It is stated below in our new language. Note that there are some terms now which are already proven. That is the Applied Binary Operation phenomenon we discussed earlier where the terms are proven by the definition of Applied Binary Operation. You can see this in the words rendering too. The key of this lemma, as with any lemma, is the freebie claim. In this lemma the claim is an equality term.</p>
            <div src="Set/lemmas/cancel" trigger="GraphViewer"/>
            <p>The idea of this lemma is that if <math><mi>a</mi><mo>&#183;</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>&#183;</mo><mi>c</mi></math>, and <math><mi>a</mi></math> has an inverse, then we get that <math><mi>b</mi><mo>=</mo><mi>c</mi></math>. It is proved by multiplying on the left by the inverse to cancel the <math><mi>a</mi></math>. Proving cancel involves the defining properties of inverse, identity, associativity, equality, as well as all the calculation steps. Seeing as how we haven't covered defining properties yet we will assume for now that cancel holds. We want to focus on how to use cancel to prove that inverses are unique.</p>
            <p>Before we show how to write the proof in our new language, let's see the steps we are trying to encode. We want to use the following proof:</p>
            <p math="">Recall <math><mi>aI1</mi></math> and <math><mi>aI2</mi></math> are assumed to be inverses of <math><mi>a</mi></math> with corresponding identity <math><mi>e</mi></math>, we are trying to prove the claim that <math><mi>aI1</mi><mo>=</mo><mi>aI2</mi></math>. By definition of inverse, <math><mi>a</mi><mo>&#183;</mo><mi>aI1</mi><mo>=</mo><mi>e</mi></math>. Likewise, <math><mi>a</mi><mo>&#183;</mo><mi>aI2</mi><mo>=</mo><mi>e</mi></math>. Therefore <math><mi>a</mi><mo>&#183;</mo><mi>aI1</mi><mo>=</mo><mi>a</mi><mo>&#183;</mo><mi>aI2</mi></math>. We know that <math><mi>a</mi></math> has an inverse because, in particular, <math><mi>aI1</mi></math> is an inverse. Thus by cancel <math><mi>aI1</mi><mo>=</mo><mi>aI2</mi></math>.</p>
            <p>Now we are ready to start writing the file which is this proof. We <a src="pages/intro/proof1" trigger="internal link">start</a> by copying the file which is the statement of the lemma.</p>
            <div src="pages/intro/proof1" trigger="xmlFile and GraphWords"/>
            <p>With that we assume all the setup for the proof. Our goal now is to change the assumption level on the term <math><mi>aI1EaI2</mi></math> to "proved." Note that we cannot just add an attribute to the term to designate it as proven because that would defeat the whole purpose of this project. Our only mechanism for obtaining an assumption level of "proved" is by invoking lemmas. We want to invoke cancel, which means we need an equality term which says that <math><mi>a</mi><mo>&#183;</mo><mi>aI1</mi><mo>=</mo><mi>a</mi><mo>&#183;</mo><mi>aI2</mi></math>. To do this, we first need to construct the product terms.</p>
            <p>The way that the defining property of inverse works requires that we consider both products <math><mi>a</mi><mo>&#183;</mo><mi>aI1</mi></math> and <math><mi>aI1</mi><mo>&#183;</mo><mi>a</mi></math>, and likewise for <math><mi>aI2</mi></math>, so we actually need to construct four applied binary operation terms. When we construct each term we need to create a new Set Element to represent the result of the application and we need to create a new Applied Binary Operation to represent the process of applying the binary operation. <a src="pages/intro/proof2" trigger="internal link">This</a> is the file with those terms created.</p>
            <div src="pages/intro/proof2" trigger="xmlFile and GraphWords"/>
            <p>Now we want to use the defining property of inverse to obtain the equality <math><mi>aaI1</mi><mo>=</mo><mi>aaI2</mi></math>. We will skip the description of these steps because they will make more sense later. We are focusing on how to apply cancel, not how to apply the defining properties of inverse or how to use the equivalence relations which equality satisfies. <a src="pages/intro/proof3" trigger="internal link">Here</a> is the proof after the steps we are skipping.</p>
            <div src="pages/intro/proof3" trigger="xmlFile and GraphWords"/>
            <p>Now we are ready to apply cancel. To do this we will build an element of type cancel, i.e. we treat cancel as a definition and build an object of the type defined by cancel. That means we have to declare which terms in our phrase will be the children of cancel. Those are given below.</p>
            <table class="proof">
                <tr>
                    <th>cancel</th>
                    <th>inverses are unique</th>
                </tr>
                <tr>
                    <td><math><mi>ass</mi></math></td>
                    <td><math><mi>ass</mi></math></td>
                </tr>
                <tr>
                    <td><math><mi>aInv</mi></math></td>
                    <td><math><mi>aInv1</mi></math></td>
                </tr>
                <tr>
                    <td><math><mi>abA</mi></math></td>
                    <td><math><mi>aaI1A</mi></math></td>
                </tr>
                <tr>
                    <td><math><mi>acA</mi></math></td>
                    <td><math><mi>aaI2A</mi></math></td>
                </tr>
                <tr>
                    <td><math><mi>abEac</mi></math></td>
                    <td><math><mi>aaI1EaaI2</mi></math></td>
                </tr>
                <tr class="proving">
                    <td><math><mi>bEc</mi></math></td>
                    <td><math><mi>aI1EaI2</mi></math></td>
                </tr>
            </table>
            <p><a src="pages/intro/proof4" trigger="internal link">Here</a> is the finished file.</p>
            <div src="pages/intro/proof4" trigger="xmlFile and GraphWords"/>
            <p>When cancel is fed these inputs, it checks that the structures match what it is expecting. Once this test is passed, our proof changes the assumption level on the term <math><mi>aI1EaI2</mi></math> to "proved." Note that you can observe in the words rendering of the compiled phrase that we successfully proved the equality term. The compiler also records that the validation of <math><mi>aI1EaI2</mi></math> was completed by cancel using the inputs in this table. The reason it records this is to check that we didn't try to pull a cyclic proof.</p>
            <p>Note that this merely proves the claim made in our lemma. To prove the lemma itself is slightly different but we can't talk about how to prove a lemma until we talk about more advanced phrase structure. The problem here is that we are supposed to not make any assumptions in the proof which aren't in the lemma, but the term <math><mi>aI1EaI2p</mi></math> of type cancel (the term which we made to apply the cancel lemma) has an assumption level of "assumed." In this context we should be allowed to assume that term because we want to treat cancel as a lemma. As it stands, we haven't stated that reliance in this file (the declaration in requiredURIs still doesn't come into play). We could have abused this phenomenon. If we had created an equality between <math><mi>aI1</mi></math> and <math><mi>aI2</mi></math> with an assumption level of assumed and then used it to prove the term <math><mi>aI1EaI2</mi></math> then we would have proven the term we needed to but it would not be a correct proof of the lemma. There is a little more that goes into proving a lemma involving how we manage extra assumptions which we have to postpone for now, but at least now we know how to apply lemmas to do proof steps.</p>
        </div>
        <div trigger="section" title="Defining Properties">
            <p>Let's look at the defining property of identity. We are trying to encapsulate this behavior:</p>
            <p math="">Let <math><mi>X</mi></math> be a set and let <math><mi>op</mi></math> be a binary operation on <math><mi>X</mi></math>, denoted with <math><mo>&#183;</mo></math>. An element <math><mi>e</mi></math> of <math><mi>X</mi></math> is an <span class="defName">identity under <math><mi>op</mi></math></span> if for all elements <math><mi>a</mi></math> of <math><mi>X</mi></math> it is true that <math><mi>a</mi><mo>&#183;</mo><mi>e</mi><mo>=</mo><math><mi>e</mi><mo>&#183;</mo><mi>a</mi><mo>=</mo><mi>a</mi></math></math>.</p>
            <p>The way to encode this property definition is to state the property as a lemma, but to mark the term we are defining with a "definingProperty" tag. You can see this <a src="Set/properties/identity" trigger="internal link">here</a>, also below.</p>
            <div src="Set/properties/identity" trigger="GraphViewer"/>
            <p>If we ignore the assumption level of "definingProperty" on the term <math><mi>id</mi></math> (meaning we pretend it is just assumed), then we can understand this statement with what has been previously covered. Namely this is a lemma which says that if we assume we have an identity and an arbitrary element then all four equality terms follow. The thing which makes this a property and not a lemma is that this process of obtaining the equalities is supposed to be logically equivalent to the existence of the Identity element. We want to be able to prove that some element is an identity and to justify creating an Identity element using that proof. How we go about proving that some element has a property must be postponed until we learn about modules, but that is the distinction between a lemma and a defining property. In our examples above we only use the lemma direction of defining properties, so technically we can now understand the entirety of the proof we used to show that inverses are unique. It uses the defining property of <a src="Set/properties/inverse">Inverse</a> which is stated below.</p>
            <div src="Set/properties/inverse" trigger="GraphViewer"/>
            <p>The proof also uses <a src="Set/properties/EqualityTransitive" trigger="internal link">transitivity of equality</a>. To use these phrases as lemmas we build them in the same way that we built cancel in the final step. It may be worth reading all of the proof now to see how the parts have come together. We aren't going to open it in a graph viewer box because there are so many nodes that we wouldn't be able to tell what is going on.</p>
            <div src="pages/intro/proof4" trigger="xmlFile and GraphWords"/>
            <p>We are only allowed to mark one element with the definingProperty tag in any given phrase.</p>
        </div>
        <div trigger="section" title="Modules">
            <p>So far we have only seen simple, direct phrases. That is, all of our files so far have only had one statements section. Modules allow us to make more suble statements in our phrases. Remember we are turning mathematical statements into graphs in this language. A module is also a graph, but it is separate from the main graph. When we add terms to the statements section the compiler alters the main graph of a phrase. When we create a term which has claims in its definition then the compiler will update the assumption levels in the main graph accordingly. However, sometimes we want to pause the main statement so we can do some work without affecting it. We do this with modules. A module is a sub-phrase of the main phrase. When the compiler comes across a module, it creates a copy of the main phrase. All the terms in the module are processed like normal but on the copy so they don't affect the main phrase. After the module is complete the compiler can then continue with the rest of the phrase.</p>
            <p>Modules are intended to allow for some functionality which is otherwise unavailable. Modules are all compiled in the manner described above, but what the compiler does with a module depends on the module's "type" attribute. This approach with typed modules gives us a tool to add to the language without rewriting the compiler. If we want to add a new feature, such as how to prove a lemma or how to prove a property, we write that feature into a module handler function. The compiler will then call that function upon reading a module with the associated module type. This makes our compiler extension-capable. We don't have to go into how to write a compiler extension program yet, but we do need to know what modules are to learn about the rest of the language.</p>
        </div>
        <div trigger="section" title="Proving a Lemma">
            <p>We have seen how to set up context, make claims, and prove terms. We also noted earlier that we cannot yet prove whole lemmas, however, because executing a proof step involves making more assumptions and the point of a proof is to not make any new assumptions. We are going to use modules to manage our assumptions and get what we want.</p>
            <p>We want to use the same <a src="pages/intro/proof4">proof</a> we saw earlier in the proof section. Before we do any proving, we first need to restate the lemma. We start with the <a src="pages/intro/proof1" trigger="internal link">file</a> below.</p>
            <div src="pages/intro/proof1" trigger="xmlFile and GraphWords"/>
            <p>Now we want to prepare for the proof. We do this by adding a module to the end of the statements section. Every module needs an id so let's name this one "m1." We want to desclare which type this module is, but we will wait to do that until after we build the module so we can see what an untyped module looks like. Inside the module we want to place the proof. The proof is identitcal to the previous proof, we just copy and paste it inside the module element. <a src="pages/intro/proof5">Here</a> is the finished file.</p>
            <div src="pages/intro/proof5" trigger="xmlFile and GraphWords"/>
            <p>Now we will go back and add the attribute of "type" to <math><mi>m1</mi></math>, setting the value of the attribute to "lemmaProof." This tells the compiler to follow the instructions in the lemmaProof module handler. We will go over those instructions before seeing the compiled file.</p>
            <p>The way a lemma should be proved is by first stating the lemma. Once the proof module is opened, our goal is to change the assumption level on any freebie terms of the lemma to proved. That is, we want to prove all the claims made by the lemma. In doing so we will almost certainly have to apply some other lemmas, and doing that involves making new assumptions. Remember the compiler doesn't distinguish between lemmas and definitions yet. To apply a lemma we build an object of its type (considering the lemma as a definition). Doing this means we are assuming the object which is the application of the lemma. If the object claims its own existence, like Applied Binary Operation, then creating it does not involve making a new assumption. It is immediately proven by its creation. If the lemma we are using has itself been proven using this process then a similar thing happens and creating it immediately proves it. If the lemma we are applying does not prove itself then it is left as a new assumption.</p>
            <p>Once the compiler has read all the terms of the proof module it will perform a check to see if this is a proof of the lemma. It first goes through each freebie claim in the lemma and checks that the assumption level is now proved. It then goes through each term in the module (except the terms in the statement of the lemma) which still has an assumption level of "assumed" and collects the types of all these objects. In the proof of inverses are unique, the compiler collects "inverseProp," "trans," and "cancel." These types are stored by the compiler as a way of saying which lemmas were used to prove that inverses are unique. Had we tried to get away with assuming the equality we are trying to show in order to prove the lemma, the compiler would record that lemma was proved using the file which defines Equality of Set Elements as a lemma. When we interpret what that means, that means that in the proof we assumed that any two set elements of the same set are always equal. That certainly is sufficient to prove our lemma, but it is not what we were trying to show. This is another example of how we cannot say anything incorrect, though it is possible to say something we did not wish to say.</p>
            <p><a src="pages/intro/proof6" trigger="internal link">Here</a> is the file with the declaration that we are proving the lemma, and below it is rendered in words.</p>
            <div src="pages/intro/proof6" trigger="xmlFile and GraphWords"/>
        </div>
        <div trigger="section" title="Future Work">
            <p>Give some ideas for other things the language should be able to accomplish.</p>
        </div>
    </body>
</html>